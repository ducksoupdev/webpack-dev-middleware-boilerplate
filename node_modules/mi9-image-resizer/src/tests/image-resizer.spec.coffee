sinon = require 'sinon'
q = require 'q'
_ = require 'lodash'
ImageResizer = require '../scripts/image-resizer'

describe 'ImageResizer', ->

    params = {
        imageResizer:
            baseUrl: 'http://imageresizer.dev.ninemsn.com.au'
    signing:
        lifetime: 60000 #ms
        region: 'ap-southeast-2'
        bucketName: 'mi9-imageresizer'
        key: 'hmac/integration'
        enabled: true
    filters:
        smart: true
    imageSet:
        sizes: [
            width: 128
        ,
            width: 256
        ,
            width: 512
        ,
            width: 1024
        ,
            width: 1440
        ,
            width: 1920
        ]
    }

    describe 'constructor', ->
        it 'should set params as settings and initialise class variables', ->
            imageResizer = new ImageResizer params
            expect(imageResizer.settings).to.be.equal params
            expect(imageResizer.cachedSigningKey).to.be.equal null
            expect(imageResizer.cachedSigningKeyTime).to.be.equal null

    describe 'instance', ->
        it 'should return an error if instance is not set', ->
            fn = ->
                ImageResizer.instance()
            expect(fn).to.throw(Error, /ImageResizer needs to be instantiated/)

        it 'should return an instance if instance is set', ->
            ImageResizer.create(params)
            expect(ImageResizer.instance()).to.be.instanceof ImageResizer

    describe 'create', ->
        it 'should create an instance of ImageResizer', ->
            imageResizer = ImageResizer.create params
            expect(imageResizer).to.be.instanceof ImageResizer

    describe 'fetchSigningKey', ->
        it 'fetches the signing key from s3 bucket and sets the expiry time', ->
            imageResizer = new ImageResizer params
            sinon.stub(imageResizer, 'getBucketContent').returns(q('key'))
            imageResizer.fetchSigningKey()
            .done ->
                expect(imageResizer.cachedSigningKey).to.be.equal 'key'
                expect(imageResizer.cachedSigningKeyTime).to.be.a 'number'

        it 'returns an error if it is not able to fetch the key', ->
            imageResizer = new ImageResizer params
            sinon.stub(imageResizer, 'getBucketContent').returns(q.reject(new Error('error')))
            imageResizer.fetchSigningKey()
            .catch (e) ->
                expect(imageResizer.cachedSigningKeyTime).to.be.equal null
                expect(e.message).to.be.equal 'error'

    describe 'getSigningKey', ->
        it 'returns the signing key if signing is enabled', ->
            imageResizer = new ImageResizer params
            imageResizer.cachedSigningKey = 'key'
            key = imageResizer.getSigningKey()
            expect(key).to.be.equal 'key'

        it 'returns an error if signing key is unavailable when signing is enabled', ->
            imageResizer = new ImageResizer params
            key = ->
                imageResizer.getSigningKey()
            expect(key).to.throw(Error, /Signing is required but no signing key available/)

        it 'returns an null when signing is disabled', ->
            params.signing.enabled = false
            imageResizer = new ImageResizer params
            key = imageResizer.getSigningKey()
            expect(key).to.be.equal null

    describe 'getResizedImageUrl', ->
        url = 'http://text.somedomain.com.au/testfolder/testimage.jpg'
        width = 200
        mockFilter = {smart: false}
        thumbor = {
            setImagePath: sinon.stub()
            resize: sinon.stub()
            buildUrl: sinon.stub().returns url
        }
        thumbor.setImagePath.returns thumbor

        it 'should return the resized url', ->

            imageResizer = new ImageResizer params
            imageResizer.Thumbor = sinon.stub().returns thumbor
            imageResizer.applyFilters = sinon.stub().returns thumbor

            resizedUrl = imageResizer.getResizedImageUrl(url, {width: 200, filters: mockFilter})

            expect(imageResizer.applyFilters).calledWith  thumbor, mockFilter
            expect(resizedUrl).to.be.a 'string'


        it 'returns null if no image source is passed', ->
            imageResizer = new ImageResizer params
            resizedUrl = imageResizer.getResizedImageUrl(null, {width: 200})
            expect(resizedUrl).to.be.a 'null'

    describe 'getResizedImageSet', ->
        url = 'http://text.somedomain.com.au/testfolder/testimage.jpg'
        width = 400

        it 'should call getResizedImageUrl with appropriate parameters', ->
            imageResizer = new ImageResizer params
            imageResizer.getResizedImageUrl = sinon.stub().returns url

            resizedUrlSet = imageResizer.getResizedImageSet(url, {width: width, filters: {smart: false}})

            expect(imageResizer.getResizedImageUrl).to.be.calledWithMatch url, {filters: {smart: false}}


        it 'should return the resized url set up to the width provided including closest greater', ->
            imageResizer = new ImageResizer params
            imageResizer.getResizedImageSetSizes = sinon.stub().returns [{width: 128}, {width: 256}, {width: 512}]
            imageResizer.getResizedImageUrl = sinon.stub().returns url

            resizedUrlSet = imageResizer.getResizedImageSet(url, {width: width, filters: {smart: false}})

            expect(resizedUrlSet).to.be.eql [
                {
                    size:
                        width: 128
                    src: url
                },
                {
                    size:
                        width: 256
                    src: url
                },
                {
                    size:
                        width: 512
                    src: url
                },
            ]

        it 'should return empty array if no url is passed', ->
            imageResizer = new ImageResizer params
            resizedUrlSet = imageResizer.getResizedImageSet(null, {width: width})
            expect(resizedUrlSet).to.be.empty

    describe 'getResizedImageSetSizes', ->
        width = 400

        it 'should return the array of sizes up to the width provided including closest greater', ->
            imageResizer = new ImageResizer params
            imageSetSizes = imageResizer.getResizedImageSetSizes({width: width})

            expect(imageSetSizes).to.be.a 'array'
            expect(imageSetSizes).to.have.length 3

        it 'should return the array of all sizes if no width is provided', ->
            imageResizer = new ImageResizer params
            imageSetSizes = imageResizer.getResizedImageSetSizes()

            expect(imageSetSizes).to.be.a 'array'
            expect(imageSetSizes).to.have.length 6




