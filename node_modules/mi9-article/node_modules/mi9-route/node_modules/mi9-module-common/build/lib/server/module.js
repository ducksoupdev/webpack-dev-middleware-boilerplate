module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!**********************************!*\
  !*** ./src/scripts/index.coffee ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var DependencyInjector, Mixin, Module,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Mixin = __webpack_require__(/*! ./mixin */ 1);
	
	DependencyInjector = __webpack_require__(/*! ./dependency-injector */ 2);
	
	Module = (function(superClass) {
	  extend(Module, superClass);
	
	  function Module() {
	    return Module.__super__.constructor.apply(this, arguments);
	  }
	
	  Module.extend(DependencyInjector);
	
	  return Module;
	
	})(Mixin);
	
	module.exports = Module;


/***/ },
/* 1 */
/*!**********************************!*\
  !*** ./src/scripts/mixin.coffee ***!
  \**********************************/
/***/ function(module, exports) {

	var MODULE_KEYWORDS, Mixin,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  slice = [].slice;
	
	MODULE_KEYWORDS = ['extended', 'included'];
	
	Mixin = (function() {
	  var propertyArgs;
	
	  function Mixin() {}
	
	  propertyArgs = function(args) {
	    var descriptor, name, scope;
	    scope = this.prototype;
	    if (args.length > 2) {
	      scope = args[0], name = args[1], descriptor = args[2];
	    } else {
	      name = args[0], descriptor = args[1];
	    }
	    return [scope, name, descriptor];
	  };
	
	  Mixin.extend = function(obj) {
	    var key, ref, value;
	    for (key in obj) {
	      value = obj[key];
	      if (indexOf.call(MODULE_KEYWORDS, key) < 0) {
	        this[key] = value;
	      }
	    }
	    if ((ref = obj.extended) != null) {
	      ref.apply(this);
	    }
	    return this;
	  };
	
	  Mixin.include = function(obj) {
	    var key, mixin, ref, value;
	    mixin = typeof obj === 'function' ? obj.prototype : obj;
	    for (key in mixin) {
	      value = mixin[key];
	      if (indexOf.call(MODULE_KEYWORDS, key) < 0) {
	        this.prototype[key] = value;
	      }
	    }
	    if ((ref = obj.included) != null) {
	      ref.apply(this);
	    }
	    return this;
	  };
	
	  Mixin.defineGetter = function() {
	    var args, getter, name, ref, scope;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    ref = propertyArgs.call(this, args), scope = ref[0], name = ref[1], getter = ref[2];
	    return Object.defineProperty(scope, name, {
	      configurable: true,
	      enumerable: true,
	      get: getter
	    });
	  };
	
	  Mixin.defineSetter = function() {
	    var args, name, ref, scope, setter;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    ref = propertyArgs.call(this, args), scope = ref[0], name = ref[1], setter = ref[2];
	    return Object.defineProperty(scope, name, {
	      configurable: true,
	      enumerable: true,
	      set: setter
	    });
	  };
	
	  return Mixin;
	
	})();
	
	module.exports = Mixin;


/***/ },
/* 2 */
/*!************************************************!*\
  !*** ./src/scripts/dependency-injector.coffee ***!
  \************************************************/
/***/ function(module, exports) {

	var Dependency, DependencyInjector;
	
	Dependency = (function() {
	  function Dependency(module1, description) {
	    this.module = module1;
	    this.description = description;
	  }
	
	  Dependency.prototype.toString = function() {
	    return ["`" + this.module + "`", this.description ? "(" + this.description + ")" : ''].filter(function(item) {
	      return item;
	    }).join(' ');
	  };
	
	  return Dependency;
	
	})();
	
	DependencyInjector = (function() {
	  var unresolved;
	
	  function DependencyInjector() {}
	
	  DependencyInjector.Dependency = Dependency;
	
	  unresolved = function(key, dependency) {
	    return function() {
	      throw new Error("[Unresolved dependency] - `" + key + "`: " + dependency);
	    };
	  };
	
	  DependencyInjector.dependencies = function(__dependencies) {
	    var dependencies;
	    this.__dependencies = __dependencies;
	    dependencies = this.__dependencies || {};
	    return Object.keys(dependencies).forEach((function(_this) {
	      return function(key) {
	        var dependency, descriptor;
	        dependency = dependencies[key];
	        if (!(dependency instanceof Dependency)) {
	          throw new Error("Dependency `" + key + "` should be an instance of `" + _this.name + ".Dependency`");
	        }
	        descriptor = unresolved(key, dependency);
	        return Object.defineProperty(_this.prototype, key, {
	          configurable: true,
	          enumerable: true,
	          get: descriptor,
	          set: descriptor
	        });
	      };
	    })(this));
	  };
	
	  DependencyInjector.registerDependencies = function(injectedDependencies) {
	    var dependencies;
	    dependencies = this.__dependencies || {};
	    if (!Object.keys(dependencies).length) {
	      return;
	    }
	    Object.keys(injectedDependencies).forEach((function(_this) {
	      return function(key) {
	        var chain, extraneous;
	        extraneous = false;
	        if (!(dependencies[key] instanceof Dependency)) {
	          extraneous = true;
	          if (!(key in dependencies) && (key in _this.prototype)) {
	            chain = _this.prototype;
	            while (!chain.hasOwnProperty(key)) {
	              chain = Object.getPrototypeOf(chain).constructor.prototype;
	            }
	            if (chain.constructor.__dependencies[key] instanceof Dependency) {
	              extraneous = false;
	            }
	          }
	        }
	        if (!extraneous) {
	          return dependencies[key] = injectedDependencies[key];
	        }
	      };
	    })(this));
	    Object.keys(dependencies).forEach((function(_this) {
	      return function(key) {
	        var dependency;
	        dependency = dependencies[key];
	        if (dependency instanceof Dependency) {
	          unresolved(key, dependency)();
	        }
	        Object.defineProperty(_this.prototype, key, {
	          configurable: true,
	          enumerable: true,
	          writable: true
	        });
	        return _this.prototype[key] = dependency;
	      };
	    })(this));
	    return this;
	  };
	
	  return DependencyInjector;
	
	})();
	
	module.exports = DependencyInjector;


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL21pOS1tb2R1bGUtY29tbW9uL3dlYnBhY2svYm9vdHN0cmFwIDcyNzc2MTQwZGExYTY5NTc3MTFmIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvbWk5LW1vZHVsZS1jb21tb24vLi9zcmMvc2NyaXB0cy9pbmRleC5jb2ZmZWUiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9taTktbW9kdWxlLWNvbW1vbi8uL3NyYy9zY3JpcHRzL21peGluLmNvZmZlZSIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL21pOS1tb2R1bGUtY29tbW9uLy4vc3JjL3NjcmlwdHMvZGVwZW5kZW5jeS1pbmplY3Rvci5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDdENBO0dBQUE7OztBQUFBLFNBQVEsb0JBQVEsZ0JBQVI7O0FBQ1Isc0JBQXFCLG9CQUFRLDhCQUFSOztBQUVmOzs7Ozs7O0dBQ0YsTUFBQyxPQUFELENBQVEsa0JBQVI7Ozs7SUFEaUI7O0FBR3JCLE9BQU0sQ0FBQyxPQUFQLEdBQWlCOzs7Ozs7Ozs7O0FDTmpCO0dBQUE7OztBQUFBLG1CQUFrQixDQUFDLFVBQUQsRUFBYSxVQUFiOztBQUVaO0FBQ0Y7Ozs7R0FBQSxlQUFlLFNBQUMsSUFBRDtBQUNYO0tBQUEsUUFBUSxJQUFDO0tBQ1QsSUFBRyxJQUFJLENBQUMsTUFBTCxHQUFjLENBQWpCO09BQ0ssZUFBRCxFQUFRLGNBQVIsRUFBYyxxQkFEbEI7TUFBQTtPQUdLLGNBQUQsRUFBTyxxQkFIWDs7QUFJQSxZQUFPLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxV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QUF4QztBQUFBOztLQUVBLE1BQU0sQ0FBQyxJQUFQLENBQVksb0JBQVosQ0FBaUMsQ0FBQyxPQUFsQyxDQUEwQztjQUFBLFNBQUMsR0FBRDtBQUN0QztTQUFBLGFBQWE7U0FDYixNQUFPLFlBQWEsS0FBYixZQUE2QixVQUFwQztXQUNJLGFBQWE7V0FFYixJQUFHLENBQUksQ0FBQyxPQUFPLFlBQVIsQ0FBSixJQUE4QixDQUFDLE9BQU8sS0FBQyxVQUFULENBQWpDO2FBQ0ksUUFBUSxLQUFDO0FBQ1Qsb0JBQU0sQ0FBSSxLQUFLLENBQUMsY0FBTixDQUFxQixHQUFyQixDQUFWO2VBQ0ksUUFBUSxNQUFNLENBQUMsY0FBUCxDQUFzQixLQUF0QixDQUE0QixDQUFDLFdBQVcsQ0FBQzthQURyRDthQUdBLElBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxjQUFlLEtBQWpDLFlBQWlELFVBQXBEO2VBQ0ksYUFBYSxNQURqQjtjQUxKO1lBSEo7O1NBVUEsS0FBcUQsVUFBckQ7a0JBQUEsWUFBYSxLQUFiLEdBQW9CLG9CQUFxQixNQUF6Qzs7T0Fac0M7S0FBQSxRQUExQztLQWNBLE1BQU0sQ0FBQyxJQUFQLENBQVksWUFBWixDQUF5QixDQUFDLE9BQTFCLENBQWtDO2NBQUEsU0FBQyxHQUFEO0FBQzlCO1NBQUEsYUFBYSxZQUFhO1NBQzFCLElBQWlDLHNCQUFzQixVQUF2RDtXQUFBLFdBQVcsR0FBWCxFQUFnQixVQUFoQjs7U0FFQSxNQUFNLENBQUMsY0FBUCxDQUFzQixLQUFDLFVBQXZCLEVBQWtDLEdBQWxDLEVBQXVDO1dBQ25DLGNBQWMsSUFEcUI7V0FFbkMsWUFBWSxJQUZ1QjtXQUduQyxVQUFVLElBSHlCO1VBQXZDO2dCQUtBLEtBQUMsVUFBVSxLQUFYLEdBQWtCO09BVFk7S0FBQSxRQUFsQztBQVdBLFlBQU87R0E3Qlk7Ozs7OztBQStCM0IsT0FBTSxDQUFDLE9BQVAsR0FBaUIiLCJmaWxlIjoibGliL3NlcnZlci9tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDcyNzc2MTQwZGExYTY5NTc3MTFmXG4gKiovIiwiTWl4aW4gPSByZXF1aXJlICcuL21peGluJ1xuRGVwZW5kZW5jeUluamVjdG9yID0gcmVxdWlyZSAnLi9kZXBlbmRlbmN5LWluamVjdG9yJ1xuXG5jbGFzcyBNb2R1bGUgZXh0ZW5kcyBNaXhpblxuICAgIEBleHRlbmQgRGVwZW5kZW5jeUluamVjdG9yXG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvZmZlZWxpbnQtbG9hZGVyIS4vc3JjL3NjcmlwdHMvaW5kZXguY29mZmVlXG4gKiovIiwiTU9EVUxFX0tFWVdPUkRTID0gWydleHRlbmRlZCcsICdpbmNsdWRlZCddXG5cbmNsYXNzIE1peGluXG4gICAgcHJvcGVydHlBcmdzID0gKGFyZ3MpIC0+XG4gICAgICAgIHNjb3BlID0gQHByb3RvdHlwZVxuICAgICAgICBpZiBhcmdzLmxlbmd0aCA+IDJcbiAgICAgICAgICAgIFtzY29wZSwgbmFtZSwgZGVzY3JpcHRvcl0gPSBhcmdzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIFtuYW1lLCBkZXNjcmlwdG9yXSA9IGFyZ3NcbiAgICAgICAgcmV0dXJuIFtzY29wZSwgbmFtZSwgZGVzY3JpcHRvcl1cblxuICAgIEBleHRlbmQ6IChvYmopIC0+XG4gICAgICAgIGZvciBrZXksIHZhbHVlIG9mIG9iaiB3aGVuIGtleSBub3QgaW4gTU9EVUxFX0tFWVdPUkRTXG4gICAgICAgICAgICBAW2tleV0gPSB2YWx1ZVxuXG4gICAgICAgIG9iai5leHRlbmRlZD8uYXBwbHkgdGhpc1xuICAgICAgICByZXR1cm4gdGhpc1xuXG4gICAgQGluY2x1ZGU6IChvYmopIC0+XG4gICAgICAgIG1peGluID0gaWYgdHlwZW9mIG9iaiBpcyAnZnVuY3Rpb24nIHRoZW4gb2JqLnByb3RvdHlwZSBlbHNlIG9ialxuICAgICAgICBmb3Iga2V5LCB2YWx1ZSBvZiBtaXhpbiB3aGVuIGtleSBub3QgaW4gTU9EVUxFX0tFWVdPUkRTXG4gICAgICAgICAgICAjIEFzc2lnbiBwcm9wZXJ0aWVzIHRvIHRoZSBwcm90b3R5cGVcbiAgICAgICAgICAgIEA6OltrZXldID0gdmFsdWVcblxuICAgICAgICBvYmouaW5jbHVkZWQ/LmFwcGx5IHRoaXNcbiAgICAgICAgcmV0dXJuIHRoaXNcblxuICAgIEBkZWZpbmVHZXR0ZXI6IChhcmdzLi4uKSAtPlxuICAgICAgICBbc2NvcGUsIG5hbWUsIGdldHRlcl0gPSBwcm9wZXJ0eUFyZ3MuY2FsbCB0aGlzLCBhcmdzXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY29wZSwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZ2V0dGVyXG4gICAgICAgIH0pXG5cbiAgICBAZGVmaW5lU2V0dGVyOiAoYXJncy4uLikgLT5cbiAgICAgICAgW3Njb3BlLCBuYW1lLCBzZXR0ZXJdID0gcHJvcGVydHlBcmdzLmNhbGwgdGhpcywgYXJnc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NvcGUsIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgICB9KVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1peGluXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvZmZlZWxpbnQtbG9hZGVyIS4vc3JjL3NjcmlwdHMvbWl4aW4uY29mZmVlXG4gKiovIiwiY2xhc3MgRGVwZW5kZW5jeVxuICAgIGNvbnN0cnVjdG9yOiAoQG1vZHVsZSwgQGRlc2NyaXB0aW9uKSAtPlxuICAgIHRvU3RyaW5nOiAtPiByZXR1cm4gW1wiYCN7QG1vZHVsZX1gXCIsIGlmIEBkZXNjcmlwdGlvbiB0aGVuIFwiKCN7QGRlc2NyaXB0aW9ufSlcIiBlbHNlICcnXS5maWx0ZXIoKGl0ZW0pIC0+IGl0ZW0pLmpvaW4oJyAnKVxuXG5jbGFzcyBEZXBlbmRlbmN5SW5qZWN0b3JcbiAgICBARGVwZW5kZW5jeTogRGVwZW5kZW5jeVxuXG4gICAgdW5yZXNvbHZlZCA9IChrZXksIGRlcGVuZGVuY3kpIC0+XG4gICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiW1VucmVzb2x2ZWQgZGVwZW5kZW5jeV0gLSBgI3trZXl9YDogI3tkZXBlbmRlbmN5fVwiXG5cbiAgICBAZGVwZW5kZW5jaWVzOiAoQF9fZGVwZW5kZW5jaWVzKSAtPlxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBAX19kZXBlbmRlbmNpZXMgb3Ige31cbiAgICAgICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzKS5mb3JFYWNoIChrZXkpID0+XG4gICAgICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2tleV1cbiAgICAgICAgICAgIHVubGVzcyBkZXBlbmRlbmN5IGluc3RhbmNlb2YgRGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciBcIkRlcGVuZGVuY3kgYCN7a2V5fWAgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIGAje0BuYW1lfS5EZXBlbmRlbmN5YFwiXG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gdW5yZXNvbHZlZChrZXksIGRlcGVuZGVuY3kpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQHByb3RvdHlwZSwga2V5LCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIGdldDogZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgIHNldDogZGVzY3JpcHRvclxuICAgICAgICAgICAgfSlcblxuICAgIEByZWdpc3RlckRlcGVuZGVuY2llczogKGluamVjdGVkRGVwZW5kZW5jaWVzKSAtPlxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBAX19kZXBlbmRlbmNpZXMgb3Ige31cbiAgICAgICAgcmV0dXJuIHVubGVzcyBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmxlbmd0aFxuXG4gICAgICAgIE9iamVjdC5rZXlzKGluamVjdGVkRGVwZW5kZW5jaWVzKS5mb3JFYWNoIChrZXkpID0+XG4gICAgICAgICAgICBleHRyYW5lb3VzID0gZmFsc2VcbiAgICAgICAgICAgIHVubGVzcyBkZXBlbmRlbmNpZXNba2V5XSBpbnN0YW5jZW9mIERlcGVuZGVuY3lcbiAgICAgICAgICAgICAgICBleHRyYW5lb3VzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICMgSWYgdGhlIGluamVjdGVkIGRlcGVuZGVuY3kgaXMgbm90IGEgZGlyZWN0IGRlcGVuZGVuY3kgY2hlY2sgaWYgaXQncyBhbiBpbmhlcml0ZWQgZGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgIGlmIG5vdCAoa2V5IG9mIGRlcGVuZGVuY2llcykgYW5kIChrZXkgb2YgQHByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSBAcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIG5vdCBjaGFpbi5oYXNPd25Qcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNoYWluKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgIyBGaW5kIHRoZSBwYXJlbnQgd2hpY2ggaGFzIHRoZSBkZXBlbmRlY3kgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiBjaGFpbi5jb25zdHJ1Y3Rvci5fX2RlcGVuZGVuY2llc1trZXldIGluc3RhbmNlb2YgRGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFuZW91cyA9IGZhbHNlXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXNba2V5XSA9IGluamVjdGVkRGVwZW5kZW5jaWVzW2tleV0gdW5sZXNzIGV4dHJhbmVvdXNcblxuICAgICAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2ggKGtleSkgPT5cbiAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNba2V5XVxuICAgICAgICAgICAgdW5yZXNvbHZlZChrZXksIGRlcGVuZGVuY3kpKCkgaWYgZGVwZW5kZW5jeSBpbnN0YW5jZW9mIERlcGVuZGVuY3lcbiAgICAgICAgICAgICMgUmVkZWZpbmUgdGhlIHByb3BlcnR5IHRvIGFsbG93IGluaGVyaXRlZCBjbGFzc2VzIHRvIGluamVjdCB0aGVpciBvd24gZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQHByb3RvdHlwZSwga2V5LCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgQHByb3RvdHlwZVtrZXldID0gZGVwZW5kZW5jeVxuXG4gICAgICAgIHJldHVybiB0aGlzXG5cbm1vZHVsZS5leHBvcnRzID0gRGVwZW5kZW5jeUluamVjdG9yXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NvZmZlZWxpbnQtbG9hZGVyIS4vc3JjL3NjcmlwdHMvZGVwZW5kZW5jeS1pbmplY3Rvci5jb2ZmZWVcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9