(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!**********************************!*\
  !*** ./src/scripts/index.coffee ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var DependencyInjector, Mixin, Module,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Mixin = __webpack_require__(/*! ./mixin */ 1);
	
	DependencyInjector = __webpack_require__(/*! ./dependency-injector */ 2);
	
	Module = (function(superClass) {
	  extend(Module, superClass);
	
	  function Module() {
	    return Module.__super__.constructor.apply(this, arguments);
	  }
	
	  Module.extend(DependencyInjector);
	
	  return Module;
	
	})(Mixin);
	
	module.exports = Module;


/***/ },
/* 1 */
/*!**********************************!*\
  !*** ./src/scripts/mixin.coffee ***!
  \**********************************/
/***/ function(module, exports) {

	var MODULE_KEYWORDS, Mixin,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  slice = [].slice;
	
	MODULE_KEYWORDS = ['extended', 'included'];
	
	Mixin = (function() {
	  var propertyArgs;
	
	  function Mixin() {}
	
	  propertyArgs = function(args) {
	    var descriptor, name, scope;
	    scope = this.prototype;
	    if (args.length > 2) {
	      scope = args[0], name = args[1], descriptor = args[2];
	    } else {
	      name = args[0], descriptor = args[1];
	    }
	    return [scope, name, descriptor];
	  };
	
	  Mixin.extend = function(obj) {
	    var key, ref, value;
	    for (key in obj) {
	      value = obj[key];
	      if (indexOf.call(MODULE_KEYWORDS, key) < 0) {
	        this[key] = value;
	      }
	    }
	    if ((ref = obj.extended) != null) {
	      ref.apply(this);
	    }
	    return this;
	  };
	
	  Mixin.include = function(obj) {
	    var key, mixin, ref, value;
	    mixin = typeof obj === 'function' ? obj.prototype : obj;
	    for (key in mixin) {
	      value = mixin[key];
	      if (indexOf.call(MODULE_KEYWORDS, key) < 0) {
	        this.prototype[key] = value;
	      }
	    }
	    if ((ref = obj.included) != null) {
	      ref.apply(this);
	    }
	    return this;
	  };
	
	  Mixin.defineGetter = function() {
	    var args, getter, name, ref, scope;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    ref = propertyArgs.call(this, args), scope = ref[0], name = ref[1], getter = ref[2];
	    return Object.defineProperty(scope, name, {
	      configurable: true,
	      enumerable: true,
	      get: getter
	    });
	  };
	
	  Mixin.defineSetter = function() {
	    var args, name, ref, scope, setter;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    ref = propertyArgs.call(this, args), scope = ref[0], name = ref[1], setter = ref[2];
	    return Object.defineProperty(scope, name, {
	      configurable: true,
	      enumerable: true,
	      set: setter
	    });
	  };
	
	  return Mixin;
	
	})();
	
	module.exports = Mixin;


/***/ },
/* 2 */
/*!************************************************!*\
  !*** ./src/scripts/dependency-injector.coffee ***!
  \************************************************/
/***/ function(module, exports) {

	var Dependency, DependencyInjector;
	
	Dependency = (function() {
	  function Dependency(module1, description) {
	    this.module = module1;
	    this.description = description;
	  }
	
	  Dependency.prototype.toString = function() {
	    return ["`" + this.module + "`", this.description ? "(" + this.description + ")" : ''].filter(function(item) {
	      return item;
	    }).join(' ');
	  };
	
	  return Dependency;
	
	})();
	
	DependencyInjector = (function() {
	  var unresolved;
	
	  function DependencyInjector() {}
	
	  DependencyInjector.Dependency = Dependency;
	
	  unresolved = function(key, dependency) {
	    return function() {
	      throw new Error("[Unresolved dependency] - `" + key + "`: " + dependency);
	    };
	  };
	
	  DependencyInjector.dependencies = function(__dependencies) {
	    var dependencies;
	    this.__dependencies = __dependencies;
	    dependencies = this.__dependencies || {};
	    return Object.keys(dependencies).forEach((function(_this) {
	      return function(key) {
	        var dependency, descriptor;
	        dependency = dependencies[key];
	        if (!(dependency instanceof Dependency)) {
	          throw new Error("Dependency `" + key + "` should be an instance of `" + _this.name + ".Dependency`");
	        }
	        descriptor = unresolved(key, dependency);
	        return Object.defineProperty(_this.prototype, key, {
	          configurable: true,
	          enumerable: true,
	          get: descriptor,
	          set: descriptor
	        });
	      };
	    })(this));
	  };
	
	  DependencyInjector.registerDependencies = function(injectedDependencies) {
	    var dependencies;
	    dependencies = this.__dependencies || {};
	    if (!Object.keys(dependencies).length) {
	      return;
	    }
	    Object.keys(injectedDependencies).forEach((function(_this) {
	      return function(key) {
	        var chain, extraneous;
	        extraneous = false;
	        if (!(dependencies[key] instanceof Dependency)) {
	          extraneous = true;
	          if (!(key in dependencies) && (key in _this.prototype)) {
	            chain = _this.prototype;
	            while (!chain.hasOwnProperty(key)) {
	              chain = Object.getPrototypeOf(chain).constructor.prototype;
	            }
	            if (chain.constructor.__dependencies[key] instanceof Dependency) {
	              extraneous = false;
	            }
	          }
	        }
	        if (!extraneous) {
	          return dependencies[key] = injectedDependencies[key];
	        }
	      };
	    })(this));
	    Object.keys(dependencies).forEach((function(_this) {
	      return function(key) {
	        var dependency;
	        dependency = dependencies[key];
	        if (dependency instanceof Dependency) {
	          unresolved(key, dependency)();
	        }
	        Object.defineProperty(_this.prototype, key, {
	          configurable: true,
	          enumerable: true,
	          writable: true
	        });
	        return _this.prototype[key] = dependency;
	      };
	    })(this));
	    return this;
	  };
	
	  return DependencyInjector;
	
	})();
	
	module.exports = DependencyInjector;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYm93ZXJfY29tcG9uZW50cy9taTktbW9kdWxlLWNvbW1vbi93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vL2Jvd2VyX2NvbXBvbmVudHMvbWk5LW1vZHVsZS1jb21tb24vd2VicGFjay9ib290c3RyYXAgM2Y4ZTllMTM5MmE3YmQ3NmEwZTciLCJ3ZWJwYWNrOi8vL2Jvd2VyX2NvbXBvbmVudHMvbWk5LW1vZHVsZS1jb21tb24vLi9zcmMvc2NyaXB0cy9pbmRleC5jb2ZmZWUiLCJ3ZWJwYWNrOi8vL2Jvd2VyX2NvbXBvbmVudHMvbWk5LW1vZHVsZS1jb21tb24vLi9zcmMvc2NyaXB0cy9taXhpbi5jb2ZmZWUiLCJ3ZWJwYWNrOi8vL2Jvd2VyX2NvbXBvbmVudHMvbWk5LW1vZHVsZS1jb21tb24vLi9zcmMvc2NyaXB0cy9kZXBlbmRlbmN5LWluamVjdG9yLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUN0Q0E7R0FBQTs7O0FBQUEsU0FBUSxvQkFBUSxnQkFBUjs7QUFDUixzQkFBcUIsb0JBQVEsOEJBQVI7O0FBRWY7Ozs7Ozs7R0FDRixNQUFDLE9BQUQsQ0FBUSxrQkFBUjs7OztJQURpQjs7QUFHckIsT0FBTSxDQUFDLE9BQVAsR0FBaUI7Ozs7Ozs7Ozs7QUNOakI7R0FBQTs7O0FBQUEsbUJBQWtCLENBQUMsVUFBRCxFQUFhLFVBQWI7O0FBRVo7QUFDRjs7OztHQUFBLGVBQWUsU0FB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S0FBQyxVQUFVLEtBQVgsR0FBa0I7T0FUWTtLQUFBLFFBQWxDO0FBV0EsWUFBTztHQTdCWTs7Ozs7O0FBK0IzQixPQUFNLENBQUMsT0FBUCxHQUFpQiIsImZpbGUiOiJsaWIvY2xpZW50L21vZHVsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgM2Y4ZTllMTM5MmE3YmQ3NmEwZTdcbiAqKi8iLCJNaXhpbiA9IHJlcXVpcmUgJy4vbWl4aW4nXG5EZXBlbmRlbmN5SW5qZWN0b3IgPSByZXF1aXJlICcuL2RlcGVuZGVuY3ktaW5qZWN0b3InXG5cbmNsYXNzIE1vZHVsZSBleHRlbmRzIE1peGluXG4gICAgQGV4dGVuZCBEZXBlbmRlbmN5SW5qZWN0b3JcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29mZmVlbGludC1sb2FkZXIhLi9zcmMvc2NyaXB0cy9pbmRleC5jb2ZmZWVcbiAqKi8iLCJNT0RVTEVfS0VZV09SRFMgPSBbJ2V4dGVuZGVkJywgJ2luY2x1ZGVkJ11cblxuY2xhc3MgTWl4aW5cbiAgICBwcm9wZXJ0eUFyZ3MgPSAoYXJncykgLT5cbiAgICAgICAgc2NvcGUgPSBAcHJvdG90eXBlXG4gICAgICAgIGlmIGFyZ3MubGVuZ3RoID4gMlxuICAgICAgICAgICAgW3Njb3BlLCBuYW1lLCBkZXNjcmlwdG9yXSA9IGFyZ3NcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgW25hbWUsIGRlc2NyaXB0b3JdID0gYXJnc1xuICAgICAgICByZXR1cm4gW3Njb3BlLCBuYW1lLCBkZXNjcmlwdG9yXVxuXG4gICAgQGV4dGVuZDogKG9iaikgLT5cbiAgICAgICAgZm9yIGtleSwgdmFsdWUgb2Ygb2JqIHdoZW4ga2V5IG5vdCBpbiBNT0RVTEVfS0VZV09SRFNcbiAgICAgICAgICAgIEBba2V5XSA9IHZhbHVlXG5cbiAgICAgICAgb2JqLmV4dGVuZGVkPy5hcHBseSB0aGlzXG4gICAgICAgIHJldHVybiB0aGlzXG5cbiAgICBAaW5jbHVkZTogKG9iaikgLT5cbiAgICAgICAgbWl4aW4gPSBpZiB0eXBlb2Ygb2JqIGlzICdmdW5jdGlvbicgdGhlbiBvYmoucHJvdG90eXBlIGVsc2Ugb2JqXG4gICAgICAgIGZvciBrZXksIHZhbHVlIG9mIG1peGluIHdoZW4ga2V5IG5vdCBpbiBNT0RVTEVfS0VZV09SRFNcbiAgICAgICAgICAgICMgQXNzaWduIHByb3BlcnRpZXMgdG8gdGhlIHByb3RvdHlwZVxuICAgICAgICAgICAgQDo6W2tleV0gPSB2YWx1ZVxuXG4gICAgICAgIG9iai5pbmNsdWRlZD8uYXBwbHkgdGhpc1xuICAgICAgICByZXR1cm4gdGhpc1xuXG4gICAgQGRlZmluZUdldHRlcjogKGFyZ3MuLi4pIC0+XG4gICAgICAgIFtzY29wZSwgbmFtZSwgZ2V0dGVyXSA9IHByb3BlcnR5QXJncy5jYWxsIHRoaXMsIGFyZ3NcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjb3BlLCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgICAgfSlcblxuICAgIEBkZWZpbmVTZXR0ZXI6IChhcmdzLi4uKSAtPlxuICAgICAgICBbc2NvcGUsIG5hbWUsIHNldHRlcl0gPSBwcm9wZXJ0eUFyZ3MuY2FsbCB0aGlzLCBhcmdzXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY29wZSwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHNldDogc2V0dGVyXG4gICAgICAgIH0pXG5cbm1vZHVsZS5leHBvcnRzID0gTWl4aW5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29mZmVlbGludC1sb2FkZXIhLi9zcmMvc2NyaXB0cy9taXhpbi5jb2ZmZWVcbiAqKi8iLCJjbGFzcyBEZXBlbmRlbmN5XG4gICAgY29uc3RydWN0b3I6IChAbW9kdWxlLCBAZGVzY3JpcHRpb24pIC0+XG4gICAgdG9TdHJpbmc6IC0+IHJldHVybiBbXCJgI3tAbW9kdWxlfWBcIiwgaWYgQGRlc2NyaXB0aW9uIHRoZW4gXCIoI3tAZGVzY3JpcHRpb259KVwiIGVsc2UgJyddLmZpbHRlcigoaXRlbSkgLT4gaXRlbSkuam9pbignICcpXG5cbmNsYXNzIERlcGVuZGVuY3lJbmplY3RvclxuICAgIEBEZXBlbmRlbmN5OiBEZXBlbmRlbmN5XG5cbiAgICB1bnJlc29sdmVkID0gKGtleSwgZGVwZW5kZW5jeSkgLT5cbiAgICAgICAgcmV0dXJuIC0+XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJbVW5yZXNvbHZlZCBkZXBlbmRlbmN5XSAtIGAje2tleX1gOiAje2RlcGVuZGVuY3l9XCJcblxuICAgIEBkZXBlbmRlbmNpZXM6IChAX19kZXBlbmRlbmNpZXMpIC0+XG4gICAgICAgIGRlcGVuZGVuY2llcyA9IEBfX2RlcGVuZGVuY2llcyBvciB7fVxuICAgICAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2ggKGtleSkgPT5cbiAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNba2V5XVxuICAgICAgICAgICAgdW5sZXNzIGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBEZXBlbmRlbmN5XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiRGVwZW5kZW5jeSBgI3trZXl9YCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgYCN7QG5hbWV9LkRlcGVuZGVuY3lgXCJcbiAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB1bnJlc29sdmVkKGtleSwgZGVwZW5kZW5jeSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShAcHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgZ2V0OiBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgc2V0OiBkZXNjcmlwdG9yXG4gICAgICAgICAgICB9KVxuXG4gICAgQHJlZ2lzdGVyRGVwZW5kZW5jaWVzOiAoaW5qZWN0ZWREZXBlbmRlbmNpZXMpIC0+XG4gICAgICAgIGRlcGVuZGVuY2llcyA9IEBfX2RlcGVuZGVuY2llcyBvciB7fVxuICAgICAgICByZXR1cm4gdW5sZXNzIE9iamVjdC5rZXlzKGRlcGVuZGVuY2llcykubGVuZ3RoXG5cbiAgICAgICAgT2JqZWN0LmtleXMoaW5qZWN0ZWREZXBlbmRlbmNpZXMpLmZvckVhY2ggKGtleSkgPT5cbiAgICAgICAgICAgIGV4dHJhbmVvdXMgPSBmYWxzZVxuICAgICAgICAgICAgdW5sZXNzIGRlcGVuZGVuY2llc1trZXldIGluc3RhbmNlb2YgRGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgIGV4dHJhbmVvdXMgPSB0cnVlXG4gICAgICAgICAgICAgICAgIyBJZiB0aGUgaW5qZWN0ZWQgZGVwZW5kZW5jeSBpcyBub3QgYSBkaXJlY3QgZGVwZW5kZW5jeSBjaGVjayBpZiBpdCdzIGFuIGluaGVyaXRlZCBkZXBlbmRlbmN5XG4gICAgICAgICAgICAgICAgaWYgbm90IChrZXkgb2YgZGVwZW5kZW5jaWVzKSBhbmQgKGtleSBvZiBAcHJvdG90eXBlKVxuICAgICAgICAgICAgICAgICAgICBjaGFpbiA9IEBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgbm90IGNoYWluLmhhc093blByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2hhaW4pLmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAgICAjIEZpbmQgdGhlIHBhcmVudCB3aGljaCBoYXMgdGhlIGRlcGVuZGVjeSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIGNoYWluLmNvbnN0cnVjdG9yLl9fZGVwZW5kZW5jaWVzW2tleV0gaW5zdGFuY2VvZiBEZXBlbmRlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYW5lb3VzID0gZmFsc2VcbiAgICAgICAgICAgIGRlcGVuZGVuY2llc1trZXldID0gaW5qZWN0ZWREZXBlbmRlbmNpZXNba2V5XSB1bmxlc3MgZXh0cmFuZW91c1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGRlcGVuZGVuY2llcykuZm9yRWFjaCAoa2V5KSA9PlxuICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1trZXldXG4gICAgICAgICAgICB1bnJlc29sdmVkKGtleSwgZGVwZW5kZW5jeSkoKSBpZiBkZXBlbmRlbmN5IGluc3RhbmNlb2YgRGVwZW5kZW5jeVxuICAgICAgICAgICAgIyBSZWRlZmluZSB0aGUgcHJvcGVydHkgdG8gYWxsb3cgaW5oZXJpdGVkIGNsYXNzZXMgdG8gaW5qZWN0IHRoZWlyIG93biBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShAcHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBAcHJvdG90eXBlW2tleV0gPSBkZXBlbmRlbmN5XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcblxubW9kdWxlLmV4cG9ydHMgPSBEZXBlbmRlbmN5SW5qZWN0b3JcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY29mZmVlbGludC1sb2FkZXIhLi9zcmMvc2NyaXB0cy9kZXBlbmRlbmN5LWluamVjdG9yLmNvZmZlZVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=