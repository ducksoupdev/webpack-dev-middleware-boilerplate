_ = require 'lodash'
moment = require 'moment'
tz = require 'moment-timezone'
uuid = require 'node-uuid'
unitize = require 'unitize'
url = require 'url'
Breakpoints = require 'mi9-breakpoints-common'

DATE_ERROR = 'Invalid Date'

# strips a base path from a given path
stripBasePath = (path, base) ->
    if typeof path is 'string'
        path = path.replace base.replace(/\/*$/, '/'),  ''

    path

# prefixes domain to a given path
absoluteUrl = (path, domain) ->
    path = path.replace /^\/*/, ''
    domain = domain.replace /\/*$/, ''

    unless domain.match /^http(s?):\/\//
        domain = "//#{domain}" # adds // prefix

    "#{domain}/#{path}"

module.exports =
    uuid: ->
        uuid.v4()

    # Limits a list to a max of n items. Useful as a subexpression.
    # e.g. {{#each (limit stories 5)}} {{/each}} to display only 5 stories
    limit: (items, limit) -> items[...limit] if items?

    # Renders a relative 'time ago' based on 'now'. If the time was more than two
    # weeks ago, fall back to `Apr 12th, 2014` format
    timeAgo: (timestamp) ->
        datetime = new Date(timestamp)
        return '' if datetime is DATE_ERROR
        time = moment datetime
        daysDiff = moment().diff time, 'days'
        if daysDiff < 14
            return time.fromNow()
        else
            return time.format 'MMM Do, YYYY'

    ticksAgo: (ticks, format = 'MMM Do, YYYY', relativeTime = null) ->

        # To customise the returned fromNow format we need to pass in the locale
        # object specifying the format of each unit e.g. { s: 'sec', m: 'min', ... }
        if relativeTime
            moment.local 'en', { relativeTime: relativeTime }

        time = moment new Date ticks
        daysDiff = moment().diff time, 'days'
        if daysDiff < 14
            return time.fromNow()
        else
            return time.format format

    # Returns a formatted string of the current date.
    currentDate: (format) ->
        now = tz moment()
        now.tz('Australia/Sydney').format(format)

    formatDate: (date, format) ->
        datetime = new Date(date)
        return '' if datetime is DATE_ERROR
        return moment(datetime).format(format)

    # Renders the domain part of a URL
    domain: (urlStr) ->
        domainExpr = /^((?:https?\:\/\/)?(?:[a-z0-9-_]+\.)*[a-z0-9-_]+\.?(?::([0-9]+))?)/i
        if domainExpr.test urlStr
            (urlStr.match domainExpr)[1]

    resizeImage: (width, src) ->
        return "http://images.ninemsn.com.au/resizer.aspx?width=#{width.toString()}&url=#{encodeURI src}"

    add: (value, addition) ->
        value + addition

    lowerCase: (text) ->
        if typeof text == 'string'
            text.toLowerCase()

    contentUrlBuilder: ({ url, domain, base }) ->
        if base   then url = stripBasePath url, base
        if domain then url = absoluteUrl url, domain

        url

    toAbsoluteUrl: absoluteUrl

    nomarkup: (html) ->
        html?.replace /<.+?>/g, ''

    pageTitle: (title, defaultTitle, titleDecoration) ->
        if title then "#{exports.nomarkup title} #{titleDecoration}" else defaultTitle

    # Used for placeholder padding (height / width)
    aspectRatio: (height, width) ->
        (height / width) * 100

    # Correct width / height aspect
    imageAspect: (width, height) ->
        aspect = width / height

    utcToLocalTimezone: (utc) ->
        datetime = new Date(utc)
        return '' if datetime is DATE_ERROR
        moment(datetime).tz(env.get 'meta:timezone').format()

    unitize: (num) ->
        unitize(num).precision(1).toString().replace(/\ /g, '')

    breakpoint: (size, type) ->
        breakpoints = new Breakpoints()
        breakpoints[size]?[type]

    showVideoBlock: (content) ->
        isArticle = content?.templateName?.toLowerCase() == 'article'
        heroIsVideo = content?.media?[0]?.type == 'video'
        return (isArticle and heroIsVideo)

