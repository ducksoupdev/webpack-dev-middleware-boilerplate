q               = require 'q'
_               = require 'lodash'
AWS             = require 'aws-sdk'
Thumbor         = require 'thumbor'

class ImageResizer

    ####
    # @params: config object
    #   imageResizer:
    #       baseUrl: Base url for images
    #       signing:
    #           lifetime: Key life in milliseconds
    #           region: AWS Region
    #           bucketName: S3 bucket name
    #           key: S3 key
    #           enabled: boolean
    #       filters:
    #           smart: boolean
    #       imageSet:
    #           sizes: Array
    ####

    instance = null

    @templates:
        imageResizer: require '../templates/image-resizer'

    @create: (params) ->
        return instance if instance
        instance = new ImageResizer(params)

    @instance: ->
        return instance if instance
        throw new Error 'ImageResizer needs to be instantiated'

    constructor: (params) ->
        @cachedSigningKey = null
        @cachedSigningKeyTime = null
        @Thumbor = Thumbor
        @settings = params

    middleware: (req, res, next) =>
        @fetchSigningKey()
        .catch (e) -> console.log 'Failed to fetch Image Resizer Signing Key', e
        .done -> next()

    fetchSigningKey: ->
        currentTime = (new Date()).getTime()
        if @settings.signing.enabled
            #Only update key if key lifetime has expired
            deltaTime = currentTime - @cachedSigningKeyTime
            if @cachedSigningKeyTime is null or deltaTime > @settings.signing.lifetime
                @cachedSigningKeyTime = currentTime

                deferred = q.defer()
                @getBucketContent @settings.signing.region, @settings.signing.bucketName, @settings.signing.key
                .done(
                    (key) =>
                        @cachedSigningKey = key if key
                        deferred.resolve @cachedSigningKey
                    (e) =>
                        #Expire cache if error occurs
                        @cachedSigningKeyTime = null
                        deferred.reject e
                )

                # If we don't have a cached key then wait for key from s3repository
                # Otherwise just return stale key and update cached key in background
                unless @cachedSigningKey
                    return deferred.promise
        q @cachedSigningKey

    getSigningKey: ->
        if @settings.signing.enabled
            if @cachedSigningKey
                @cachedSigningKey
            else
                throw new Error 'Signing is required but no signing key available'
        else
            null

    getBucketContent: (region, bucket, key) ->
        deferred = q.defer()
        s3 = new AWS.S3
            region: region

        s3.getObject
            Bucket: bucket
            Key: key
            (err, data) ->
                if err
                    console.log "Failed to retrieve #{bucket}/#{key} from S3", err
                    deferred.reject err
                else
                    deferred.resolve data?.Body
        deferred.promise

    getDefaultOptions: ->
        width: 0
        height: 0

    getResizedImageUrl: (source, options) ->
        if source
            try
                #encode image source required for Akamai (super weird)
                encodedSource = encodeURIComponent decodeURIComponent source
                key = @getSigningKey()
                options = _.merge {}, @getDefaultOptions(), options
                thumbor = new @Thumbor key, @settings.baseUrl
                thumbor.setImagePath encodedSource
                .resize options.width, options.height

                filters = _.merge @settings.filters, options.filters

                @applyFilters(thumbor, filters).buildUrl()
            catch e
                console.log 'Failed to generate thumbor url', e
                source
        else
            null

    applyFilters: (thumbor, filters) ->
        thumbor.smartCrop filters.smart
        thumbor.halign filters.align.horizontal if filters.align?.horizontal
        thumbor.valign filters.align.vertical if filters.align?.vertical
        thumbor

    getResizedImageSet: (source, options, aspect) ->
        if source
            imageSetSizes = @getResizedImageSetSizes options
            imageSetSizes.map (item) =>
                item?.height = if aspect then Math.round(item?.width / aspect) else 0
                options = _.merge {}, options, item
                size:
                    width: item?.width
                src: @getResizedImageUrl source, options
        else
            []

    getResizedImageSetSizes: (options) ->
        #if width is specified we only want the image set widths up to the width just greater
        imageSetSizes = []
        if options and options.width
            for size in @settings.imageSet.sizes
                imageSetSizes.push size
                break if size.width > options.width
        else
            imageSetSizes = @settings.imageSet.sizes

        imageSetSizes

module.exports = ImageResizer
